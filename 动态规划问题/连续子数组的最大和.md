输入一个 **非空** 整型数组，数组里的数可能为正，也可能为负。
数组中一个或连续的多个整数组成一个子数组。
求所有子数组的和的最大值。
要求时间复杂度为 O(n)O(n)。
#### 数据范围
数组长度 [1,1000][1,1000]。
数组内元素取值范围 [−200,200][−200,200]。
#### 样例
```
输入：[1, -2, 3, 10, -4, 7, 2, -5]

输出：18
```
> 来自: [55. 连续子数组的最大和 - AcWing题库](https://www.acwing.com/problem/content/50/)


---

```python
class Solution(object):
    def maxSubArray(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        max_sum = nums[0]
        cur_sum = nums[0]

        for num in nums[1:]:
            cur_sum = max(cur_sum+num,num)
            max_sum = max(cur_sum,max_sum)

        return max_sum

new =Solution()
nums =[1, -2, 3, 10, -4, 7, 2, -5]
print(new.maxSubArray(nums))

```

1. 首先，我们定义了两个变量 **max_sum** 和 **cur_sum**，它们分别用来记录全局最大子数组和和当前子数组和。
2. 我们从数组的第二个元素开始遍历，因为第一个元素我们已经初始化为 **cur_sum** 和 **max_sum**。
3. 对于每个元素 **num**：
   - 我们先更新 **cur_sum**，如果当前子数组和加上 **num** 大于 **num**，说明当前子数组和仍然是正的，可以继续加上当前元素 **num**；否则，我们将 **cur_sum** 更新为 **num**，重新开始计算子数组和。
4. 在更新完 **cur_sum** 后，我们比较当前的 **cur_sum** 和 **max_sum**，将较大的值赋给 **max_sum**。这样就保证了 **max_sum** 始终记录着遍历过程中的最大子数组和。
5. 最终，当遍历完整个数组后，**max_sum** 就是我们所求的最大子数组和。

这种动态规划的思想实际上是利用了局部最优解来推导全局最优解，每一步都选择局部最优解，并在每一步都更新全局最优解。

---

这个问题实际上是经典的动态规划问题，其数学思想可以用递推式来表达。在这个问题中，我们需要求解的是最大子数组和，假设我们已经知道了前 i-1 个元素的最大子数组和，那么我们如何利用这个信息来求解前 i 个元素的最大子数组和呢？
假设数组为 nums，我们用 **dp[i]** 表示以第 i 个元素结尾的子数组的最大和，那么我们可以得到如下的递推关系：

- 如果 **dp[i-1]** 大于 0，那么 **dp[i] = dp[i-1] + nums[i]**，表示当前元素加入前面的子数组可以得到更大的和；
- 如果 **dp[i-1]** 小于等于 0，那么 **dp[i] = nums[i]**，表示当前元素单独构成一个子数组，此时子数组和就是当前元素本身。

通过上述递推关系，我们可以写出状态转移方程：
```
cssCopy code
dp[i] = max(dp[i-1] + nums[i], nums[i])
```
初始条件为 **dp[0] = nums[0]**，因为以第一个元素结尾的子数组就是它本身。
最终，我们只需遍历一遍数组，不断更新 **dp[i]**，然后在遍历过程中记录下最大的 **dp[i]**，就是数组的最大子数组和。
这个数学思想通过动态规划的方法，将一个较大的问题分解为了若干个小问题，并通过逐步求解小问题的最优解来求解整个问题的最优解。
